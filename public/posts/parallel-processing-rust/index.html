<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>%!s(&lt;nil&gt;) | Ashwin Sundar</title>

    <link rel="stylesheet" href="/css/o.posts.tw.css">



</head>

<body class="p-6 md:p-12 bg-paper">
  <header class="pb-8">
    <h1 class="text-2xl text-gray-400">Ashwin Sundar</h2>


  </header>
  <main>
    
  <h1>Parallel Processing in Rust</h1>

  
  
  <time datetime="2022-04-06T00:00:00&#43;00:00">April 6, 2022</time>

  <h1 id="parallel-processing-in-rust">Parallel Processing in Rust</h1>
<p>Date: April 6th, 2022</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a systems programming language that is quickly gaining traction at well-known companies including Amazon, Discord, Dropbox, Meta, Alphabet, and Microsoft. It is built for <a href="https://www.rust-lang.org/">performance, reliability, and productivity</a> and has been voted the most loved programming language according to Stack Overflow&rsquo;s <a href="https://insights.stackoverflow.com/survey">Annual Developer Survey</a> since 2016. Some large-scale commercial projects that have been built using Rust include:</p>
<ul>
<li>Mozilla&rsquo;s <a href="https://servo.org/">Servo</a> parallel browser engine</li>
<li>Discord&rsquo;s <a href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f">Read States</a> service</li>
<li>Polkadot&rsquo;s <a href="https://github.com/paritytech/polkadot">Substrate</a> blockchain engine</li>
<li>Figma&rsquo;s <a href="https://www.figma.com/blog/rust-in-production-at-figma/">Multiplayer</a> service</li>
</ul>
<p>All of these real-world use cases of Rust utilize and benefit from concurrent and parallel processing, which can be daunting to implement on a good day, and pretty terrifying when implemented <a href="https://en.wikipedia.org/wiki/Therac-25">badly</a>. Rust helps mitigate concurrency hazards by design, but it&rsquo;s still up to the programmer to construct their program logic thoughtfully so they can take advantage of the power of concurrent and parallel processing.</p>
<p><strong>When should I use concurrent or parallel processing, instead of serial processing?</strong></p>
<p>Most modern processors have multiple cores to work with, which means you can use these cores to achieve significant performance gains:</p>
<ul>
<li>When you have a lot of independent computations to process, such as a giant for-loop.</li>
<li>When some of your threads contain computations that are particularly lengthy to calculate. It&rsquo;s nice to run these on the &ldquo;backburner&rdquo; without blocking your program from performing other computations.</li>
<li>When you have low <a href="https://www.mathworks.com/help/parallel-computing/decide-when-to-use-parfor.html">parallel overhead</a></li>
</ul>
<p><strong>How do I implement parallel processing in Rust?</strong>
My favorite way to learn new programming languages is by combining it with my love for math and solving problems in <a href="https://projecteuler.net/">Project Euler</a>. To demonstrate parallelization in Rust, let&rsquo;s solve a <a href="https://projecteuler.net/problem=1">simple problem</a> that I tweaked slightly so we can focus on the implementation of our solution:</p>
<p><em>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1,000,000.</em></p>
<p><strong>Solution Methodology</strong>
While the mathematically elegant solution would be to use an <a href="https://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic series</a>, let&rsquo;s just focus on the simple solution, which is to figure out if each number in the range is divisible by 3 or 5. If it is, let&rsquo;s add it to a running sum we&rsquo;re keeping track of.</p>
<p><strong>Example 1 - No parallelization</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_unpar</span>(input: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>input {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    sum
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Code walkthrough:</strong> In this example, we accept an <code>input</code>, and iterate on every number between <code>1..input</code> to determine if it is divisible by 3 or 5 using the modulo <code>%</code> operator. If it is, then add the value to a running <code>sum</code> we&rsquo;re keeping track of. At the end, return the sum. In Rust, you can return a value by simply calling it without a semicolon after the expression. Since Rust is a <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a> language, we need to tell the compiler to add the original <code>i32</code> input and convert the sum to an <code>i64</code>, so that we have enough space to store the answer.</p>
<p>Let&rsquo;s calculate a performance benchmark for this function so we can compare it to our multithreaded optimization that we&rsquo;ll write next. We can calculate this benchmark with the <a href="https://docs.rs/easybench/latest/easybench/">easybench</a> crate, an importable package in Rust.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> easybench::{bench};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>;
</span></span><span style="display:flex;"><span>println!(<span style="color:#e6db74">&#34;euler1_unpar: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, bench(<span style="color:#f92672">||</span> euler1_unpar(input) ) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;&gt;</span> euler1_unpar: <span style="color:#ae81ff">14.429298</span>ms (R<span style="color:#960050;background-color:#1e0010">²</span><span style="color:#f92672">=</span><span style="color:#ae81ff">0.999</span>, <span style="color:#ae81ff">70</span> iterations <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">21</span> samples)
</span></span></code></pre></div><p>Our unparallelized function takes about <code>14.4</code> milliseconds to execute.</p>
<p><strong>Example 2 - Parallelized (2 threads)</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">euler1_par</span>(input: <span style="color:#66d9ef">i32</span>) -&gt; <span style="color:#66d9ef">i64</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">use</span> std::thread;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle1 <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> thread1_sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>input <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                thread1_sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        thread1_sum
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> handle2 <span style="color:#f92672">=</span> thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> thread2_sum: <span style="color:#66d9ef">i64</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> (input <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">..</span>input {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                thread2_sum <span style="color:#f92672">+=</span> i <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        thread2_sum
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    handle1.join().unwrap() <span style="color:#f92672">+</span> handle2.join().unwrap()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Code walkthrough:</strong> Here, we use the <code>thread</code> module so that we can take advantage of the native multithreading available in Rust. A new thread is created by calling <code>thread::spawn</code>, into which a <code>closure</code> is passed. <a href="https://doc.rust-lang.org/book/ch13-01-closures.html">Closures</a> are anonymous functions that allow you to access environment variables, such as the <code>input</code> variable. This closure does the same mathematical computation as <code>euler1_unpar</code>, except we only process one half of the total range in the thread. The other half is saved for the second thread. We also need to <code>move</code> a copy of the input into the closure&rsquo;s scope so that the thread can take ownership of the data and use it. Writing code like this can seem tedious and time-consuming, but is required by Rust to help reduce the risk of <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">concurrency errors</a>.</p>
<p><code>thread::spawn</code> returns a <code>JoinHandle</code> type, which contains some convenience methods that allow us to take back control over the threads and handle their results. In this case, <code>JoinHandle::join()</code> halts execution of the function until our threads have finished their calculations. <code>.unwrap()</code> exposes the answers we&rsquo;ve calculated in each thread, and then finally we sum those answers up.</p>
<p>Let&rsquo;s see how long this function takes to run:</p>
<pre tabindex="0"><code>use easybench::{bench};
let input = 1000000;
println!(&#34;{}&#34;, euler1_par(input));

&gt; euler1_par:  7.345441ms (R²=0.998, 133 iterations in 27 samples)
</code></pre><p>The parallelized function takes about <code>7.3</code> milliseconds to execute.</p>
<p><strong>Conclusion</strong>
The parallelized code runs almost twice as fast as our unparallelized code, and we seem to only lose a little performance due to the overhead of setting up the threads. Nice!</p>
<p>This example demonstrates a way to get started with parallel processing in Rust. You often need to design your program with parallelization in mind from the get-go, as you are forced to think about the flow of your code and determine what pieces of the code take the longest to run and would benefit from parallelization.</p>
<p><em>This article was originally written for the <a href="https://engineering.deptagency.com/parallel-processing-in-rust">engineering blog</a> at DEPT®, a technology consultancy</em></p>

  


  </main>
  <footer class="pt-8">
    <p>Copyright 2024. All rights reserved.</p>

  </footer>
</body>
</html>
